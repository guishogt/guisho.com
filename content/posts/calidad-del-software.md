---
_edit_last: "2"
_jetpack_related_posts_cache:
  8f6677c9d6b0f903e98ad32ec61f8deb:
    expires: 1771668528
    payload:
      - id: 150
      - id: 3381
      - id: 773
_oembed_1f5cb075554df2fa28188a2cdf51e8b6: '{{unknown}}'
_oembed_3bc1608772f82402a114e5888d1c7606: '{{unknown}}'
_oembed_4aab7e1eace33e03fbdc5179b26795b5: '{{unknown}}'
_oembed_5ec593bb421dec9bde33838c07183ce5: '{{unknown}}'
_oembed_8c9a91622b0ee93d15b0ff6fbe6c11da: '{{unknown}}'
_oembed_0015bd7a87ffa06831a4221f449a55fe: '{{unknown}}'
_oembed_37d6c56018412df23aaa48b594568c8f: '{{unknown}}'
_oembed_78d52fcedd603674e455d31b27c99bf6: <a href="http://synergix.wordpress.com/2008/07/02/modelo-de-calidad-tradicional-del-software/">Modelo de Calidad Tradicional del&nbsp;Software</a>
_oembed_320d46abd6d2a89a270cd04d5f291b30: '{{unknown}}'
_oembed_533c3a0945eb2b4e44942ee81433ee6e: '{{unknown}}'
_oembed_634c2006ac2340484ea6cea5894b7c7d: '{{unknown}}'
_oembed_5657e275097c887d5a04eac7e141315b: '{{unknown}}'
_oembed_005726f822bb5f52d3cb87eb30926447: '{{unknown}}'
_oembed_8867e11fa6de3f7338c9428825d60987: '{{unknown}}'
_oembed_41581fc3d49cd07a684b05da204ad348: '{{unknown}}'
_oembed_69647a44ea420ecc4d686717d4d07e58: '{{unknown}}'
_oembed_536715ef8fdc0e0365edb8ee1c110ec3: '{{unknown}}'
_oembed_4264616f04c237847e2f6bbd935eeab6: <a href="http://synergix.wordpress.com/2008/07/02/modelo-de-calidad-tradicional-del-software/">Modelo de Calidad Tradicional del&nbsp;Software</a>
_oembed_a9af32052b9dc57138ce703053485a4d: '{{unknown}}'
_oembed_a89e8e08bd3e9529a831121de6e37035: '{{unknown}}'
_oembed_af2046da9614a9c28b6963de3ce3e0c9: '{{unknown}}'
_oembed_ca46a6351866ee0f325e1ce9728baf3e: '{{unknown}}'
_oembed_cd51caf1ab5226b8c41c1481355b4733: '{{unknown}}'
_oembed_d7fb4830dfadf20f957ceb59ea889b46: '{{unknown}}'
_oembed_d94c8be2cf3852bc21bf0f66f650b34f: '{{unknown}}'
_oembed_dd81bb5c11d61c22640145f1b80b8ceb: '{{unknown}}'
_oembed_de5b0dcdef9d911547f8262f98b57f81: '{{unknown}}'
_oembed_eda278e11198f1dc324f5d91d4c33f5b: '{{unknown}}'
_oembed_f15c8ef51e837eb2024847d639c0e26a: '{{unknown}}'
_oembed_f77f0105ac91729dbc092c3c778a22cf: <a href="http://synergix.wordpress.com/2008/07/02/modelo-de-calidad-tradicional-del-software/">Modelo de Calidad Tradicional del&nbsp;Software</a>
_oembed_f8332f15a49f5edb85dc908e5ee82d17: '{{unknown}}'
_oembed_fc68890fa49fcc3b68a022a636fd288a: '{{unknown}}'
_oembed_time_78d52fcedd603674e455d31b27c99bf6: "1461380493"
_oembed_time_4264616f04c237847e2f6bbd935eeab6: "1460378913"
_oembed_time_f77f0105ac91729dbc092c3c778a22cf: "1461550284"
_wpas_done_all: "1"
_wpcom_is_markdown: "1"
author: guisho Luis H. Fernandez
categories:
  - software-business
  - software-engineering
date: "2008-11-29T22:15:27+00:00"
guid: http://software.guisho.com/?p=16
parent_post_id: null
post_id: "746"
rank_math_internal_links_processed: "1"
rank_math_robots:
  - index
summary: |-
  Calidad en el software.
  El término calidad siempre me ha parecido ambiguo. ¿Que hace que un bien o servicio "posea" calidad? No sé. Hay procesos de calidad, chequeos de calidad, y mil cosas con calidad, pero nadie entiende a ciencia cierta qué es calidad, aunque todos comprenden el término. Aunque para algunos es aquel software que no tiene bugs, para otros el que satisface al cliente, para otros es el que optimiza recursos, para otros el que se mira bonito, etc.
tags:
  - calidad
  - calidad-del-software
  - software
title: Calidad del software
url: /calidad-del-software/
views: "13820"

---
Calidad en el software.

El término calidad siempre me ha parecido ambiguo. ¿Que hace que un bien o servicio "posea" calidad? No sé. Hay procesos de calidad, chequeos de calidad, y mil cosas con calidad, pero nadie entiende a ciencia cierta qué es calidad, aunque todos comprenden el término. Aunque para algunos es aquel software que no tiene bugs, para otros el que satisface al cliente, para otros es el que optimiza recursos, para otros el que se mira bonito, etc.

Cuando el término entra al contexto del software, la cosa se pone peor. ¿Qué hace que un software sea uno de calidad o no? Claro, debido a lo ambiguo del término, la discusión en este tema no tendrá fin.

Con todo, lo que hacemos es software, y nos gustaría hacer siempre software de calidad. Para poder etiquetar a un software como uno de calidad, debemos definir algunos atributos para poder poner el software en evaluación. Estos atributos, y sus prioridades, cambian cuando cambia el contexto de software: un sistema para hospitales se juzga de una manera distinta a una página web.

En FFSE R. Glass propone siete atributos del software que le confieren lo que llamamos calidad:
+Portabilidad: la portabilidad implica que un programa puede correr en distintas plataformas, no sólo de sistemas operativos sino diferentes versiones, diferentes ambientes y esquemas.
+Fiabilidad o confiabilidad: el software hace lo que debería hacer, y no "truena".
+Eficiencia: que tanto recursos economiza en tiempo y espacio el software.
+Facilidad de uso: es fácil de usar?
+Evaluable: Es sencillo de examinar? Se le pueden correr fácilmente unit tests?
+Leíble: Es el código expresivo y fácil de comprender?
+Mofificable: Qué tan sencillo es modificar el software.
+Escalibilidad: pueden agregarse funciones de manera rápida y consistente?

Buscando en internet, encontré otros atributos que vale la pena mencionar:

+Compatibilidad: es el software amigable con otros sistemas?
+Seguridad: es el software seguro contra ataques externos?

Todos concordarán que los atributos anteriores son buenos parámetros para medir la calidad de un producto de software. Sin embargo el orden de estos productos varían de proyecto a proyecto. Un proyecto que maneja información confidencial puede que tenga la seguridad muy alta, una página de internet tendrá muy alta la facilidad de uso, un software bancario tomará más en cuenta la fiabilidad que la portabilidad.

**El usuario y el código**

Al usuario final le viene del norte en qué tecnología corre un programa, o que metodología de desarrollo se utilizó para su creación. Poco le importa si se utilizó un lenguaje de cuarta generación o assembler. El usuario toma por sentado ciertos estándares y cierta funcionalidad. Por ejemplo un usuario espera siempre que en el lugar que aparezca un disquete se grabe su trabajo. Si esto no funciona bien, el usuario tendrá una muy mala percepción del software, y por tanto el software no tendrá mucha calidad.

El otro lado de la moneda es la calidad del código. ¿Es sencillo de encontrar errores? ¿Hay un buen uso del modelo de programación? ¿Se optimiza el uso del hardware? Aquí cada quien tiene un criterio diferente, hay filosofías, metodologías, paradigmas y demás.

Glass expone algo que me llamó mucho la atención: la satisfacción del cliente no es lo mismo que calidad de software. Entre los elementos que evalúa el cliente están cosas como el precio del producto, el diseño, el tiempo de entrega, el soporte y otros. Un mal software puede tener una alta satisfacción (aunque poco probable), y un buen software puede ser mal valuado por el usuario (créanme, sucede). Entonces la política de calidad de la empresa en general es distinta a la política de calidad del software en sí. Pese a muchas opiniones, el software es el código y nada más. Otras cosas le van unidas, pero no son software.

En Pragmatic Programme Hunt y Thomas exponen un punto importante: software lo suficientemente bueno. En ocasiones, especialmente cuando no hay restricciones de calendario, el desarrollador quiere siempre mejorar su software. Irónicamemte un software puede ser siempre mejorado. Hay que aprender cuando un software es lo suficientemnete bueno, porque agregarle funcionalidad o mejoras puede ser hasta contraproducente si no se sabe donde parar. Al final esto es ingeniería de software, y como todas las ingenierías nuestro objetivo es calcular. Si voy a comprar alambre para cercas las plantas de mi casa puedo calcular la circunferencia usando 3 en vez de pi, si voy calcular los materiales necesarios para un edificio redondo seguramente usaré 3.14159 o tal vez más dígitos, y si estoy calculando la órbita de una nave espacial definitivamente usaré más decimales. Hay que saber cual me conviene más. Lo mismo en el software.

Existe un ISO, el 9126 que se dedica a la calidad de software tiene puntos muy interesantes. Especialmente me gustó la división que hacen para medir la calidad: la calidad del modelo, la calidad de la métrica externa, la de la métrica interna y la calidad en el uso de las métricas. Está también CMMI que se dedica a la calidad estandarizar la calidad del software y la calidad del proceso productivo de éste.

En fin la calidad de software es algo que radica entre lo objetivo y lo subjetivo. Hay mucha leña por ahí para partir, porque el universo del software es también dinámico y los parámetros también cambian. Cada equipo de trabajo tiene sus propios parámetros. Lo que quiero recalcar es que cada equipo debe definir cuales son sus parámetros para medir la calidad de su software. Luego modelar, diseñar, implementar y mantener el software apegado a esos claves. En cada proyecto el orden de prioridades cambian también y hay que tenerlo presente, porque al final de los cantares lo que queremos es que nuestro software funcione, le guste al usuario y se acerque lo más ppsible a hacer lo que tiene que hacer.

**Luis H. Fernandez**
**luishernan@gmail.com**
Algunos links.

http://synergix.wordpress.com/2008/07/02/modelo-de-calidad-tradicional-del-software/
http://blog.xebia.com/2008/11/05/what-exactly-is-software-quality/
http://en.wikipedia.org/wiki/Software\_quality
http://satc.gsfc.nasa.gov/support/STC\_APR96/qualtiy/stc\_qual.PDF
http://en.wikipedia.org/wiki/ISO\_9126
http://www.bth.se/tek/besq.nsf/(WebFiles)/CF1C3230DB425EDCC125706900317C44/$FILE/chapter\_1.pdf  
[онлайн казино адмирал игровые автоматы](http://admiral-apparaty.com)
